# 总览
## 关键变量内容解析
1. 对-g版本的ELF文件，解析其DWARF调试信息，递归解析出需要分析的结构体信息，用于后续进行内存的排布分析。（一般工具需要依赖提供配套的.h文件，用来解析结构体。解析-g可使得不需要依赖特定版本的头文件）（难点）
2. 解析ELF文件，获取需要的全局变量的地址。由于内核态基地址为0x40000000，可得到全局变量的相对偏移
3. 结合1,2两步的信息，将导出的内存文件mmap到内存，根据第二步得到的相对偏移和内存排布，可解析出全局变量代表的结构体的各个关键字段的信息
4. 扩展性：开发人员可根据自己的需要，扩展获取自己需要的变量和字段信息

## 调用栈的分析
1. 对于map文件的解析，需要获取到地址和函数的对应关系
2. 对于每个任务，任务信息存储于g_losTask所代表的的结构体里，可解析获得；解析调用栈依赖的寄存器信息，存储于context结构体里
3. 根据gcc、llvm、iar等编译器的特点，结合上述信息，进行调用栈的推断

# 工具集用法
## 关键变量内容解析
1. 结构体分析工具：headers_from_dwarf.py用于从包含DWARF的ELF文件中生成需要的结构体，依赖的三方工具是dwarf_to_c。
   基本用法：`headers_from_dwarf.py liteos`
   生成类似如下的C代码：
   ```
   struct LOS_DL_LIST
   {
        struct LOS_DL_LIST *pstPrev; /* +0x0 */
        struct LOS_DL_LIST *pstNext; /* +0x4 */
   };
   typedef struct LOS_DL_LIST LOS_DL_LIST;
   ```
   该代码即可用来解析一个LOS_DL_LIST结构体。

   当然，因为需要将依赖的结构体进一步解析，因而实际的结构体比这个要复杂得多，可以参见example-LosTaskCB.h示例。

** 难点 ** GCC、LLVM等生成的dwarf文件有一定差异，在强制使用-dwarf3标准的情况下，生成的文件仍然有一定问题，尝试解析了LosTaskCB这个非常复杂的结构体，针对具体的问题，解决差异，部分已提交PR：`https://github.com/laanwj/dwarf_to_c/pull/6`

2. 全局变量地址获取：`get_symbol_addr.py`，本步骤较为简单，利用pyelftools工具解析ELF文件，过滤需要的全局变量即可。根据内核态的基址，即可得到该全局变量在内核中的偏移值。
3. 全局变量及关键变量的解析：将

# TODO
